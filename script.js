import { components, templates } from './components.js';
import { EditorView, basicSetup } from 'https://esm.sh/codemirror@6.0.1';
import { html } from 'https://esm.sh/@codemirror/lang-html@6.4.5';
import { css } from 'https://esm.sh/@codemirror/lang-css@6.2.0';
import { javascript } from 'https://esm.sh/@codemirror/lang-javascript@6.1.9';
import { oneDark } from 'https://esm.sh/@codemirror/theme-one-dark@6.1.2';
import { WebContainer } from 'https://esm.sh/@webcontainer/api@1.1.8';

const API_KEY = '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';

// State
let state = {
    view: 'initial', // initial | project
    sidebarOpen: false,
    history: [],
    isGenerating: false,
    activeFile: 'index.html',
    webContainerLoaded: false,
    serverUrl: null,
    files: {
        'index.html': { content: '<!-- Waiting for generation... -->' },
        'styles.css': { content: '/* Global styles */\nbody {\n  margin: 0;\n  font-family: sans-serif;\n}' },
        'script.js': { content: '// Interactive logic\nconsole.log("Hello world");' },
        'package.json': { content: '{\n  "name": "lovable-project",\n  "type": "module",\n  "dependencies": {\n    "serve": "latest"\n  },\n  "scripts": {\n    "start": "serve ."\n  }\n}' },
        'README.md': { content: '# Project\n\nGenerated by Lovable.' }
    }
};

let editor; // CodeMirror instance
let webContainerInstance; // WebContainer instance

// Elements
const els = {
    sidebar: document.getElementById('sidebar'),
    sidebarToggle: document.getElementById('sidebar-toggle'),
    emptyState: document.getElementById('empty-state'),
    projectView: document.getElementById('project-view'),
    initialInput: document.getElementById('initial-input'),
    initialSendBtn: document.getElementById('initial-send-btn'),
    chatInput: document.getElementById('chat-input'),
    chatSendBtn: document.getElementById('chat-send-btn'),
    messagesContainer: document.getElementById('messages-container'),
    previewFrame: document.getElementById('preview-frame'),
    codeView: document.getElementById('code-view'),
    terminalView: document.getElementById('terminal-view'),
    terminalOutput: document.getElementById('terminal-output'),
    codeEditorMount: document.getElementById('code-editor-mount'),
    fileList: document.getElementById('file-list'),
    statusIndicator: document.getElementById('status-indicator'),
    suggestions: document.querySelectorAll('.pill'),
    tabs: document.querySelectorAll('.tab'),
    historyBtn: document.getElementById('history-btn')
};

// Audio
const successAudio = new Audio('success_chime.mp3');

// Initialization
document.addEventListener('DOMContentLoaded', () => {
    lucide.createIcons();
    
    // Start WebContainer Boot Process
    initWebContainer();

    // Sidebar Toggle
    els.sidebarToggle.addEventListener('click', () => {
        state.sidebarOpen = !state.sidebarOpen;
        if (state.sidebarOpen) {
            els.sidebar.classList.add('open');
        } else {
            els.sidebar.classList.remove('open');
        }
    });

    // Initialize Editor
    initEditor();

    els.initialSendBtn.addEventListener('click', () => handleInput(els.initialInput.value));
    els.chatSendBtn.addEventListener('click', () => handleInput(els.chatInput.value));
    
    // Enter key support
    [els.initialInput, els.chatInput].forEach(input => {
        input.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                handleInput(input.value);
            }
        });
    });

    // Suggestions
    els.suggestions.forEach(btn => {
        btn.addEventListener('click', () => handleInput(btn.dataset.prompt));
    });

    // Tabs
    els.tabs.forEach(tab => {
        tab.addEventListener('click', () => {
            // Update Active State
            els.tabs.forEach(t => t.classList.remove('active'));
            tab.classList.add('active');

            // Toggle View
            const view = tab.dataset.view;
            els.previewFrame.classList.add('hidden');
            els.codeView.classList.add('hidden');
            els.terminalView.classList.add('hidden');

            if (view === 'code') {
                els.codeView.classList.remove('hidden');
            } else if (view === 'terminal') {
                els.terminalView.classList.remove('hidden');
            } else {
                els.previewFrame.classList.remove('hidden');
            }
        });
    });

    renderFileExplorer();
    displayFile(state.activeFile);

    // History Button (Simple functionality for now)
    if(els.historyBtn) {
        els.historyBtn.addEventListener('click', () => {
            // In a real app, this would toggle a history pane
            alert('History feature coming soon!');
        });
    }
});

// Core Logic
async function handleInput(text) {
    if (!text.trim() || state.isGenerating) return;
    
    // Clear inputs
    els.initialInput.value = '';
    els.chatInput.value = '';

    // Switch view if needed
    if (state.view === 'initial') {
        state.view = 'project';
        els.emptyState.classList.add('hidden');
        els.projectView.classList.remove('hidden');
        
        // Trigger WebContainer file mount and start if first time
        if (webContainerInstance) {
            await mountFiles();
            startDevServer();
        }
    }

    // Add User Message
    addMessage('user', text);
    
    // Start Generation
    state.isGenerating = true;
    updateStatus(true);
    
    // Add AI Message container
    const aiMsgId = addMessage('ai', "Thinking...");
    const aiMsgEl = document.getElementById(aiMsgId);
    const contentEl = aiMsgEl.querySelector('.msg-content');

    let accumulatedCode = "";

    try {
        contentEl.innerHTML = `Starting generation...`;
        
        await generateWithAI(text, (chunk) => {
            accumulatedCode += chunk;
            
            // Update UI feedback
            contentEl.innerHTML = `Building... <span style="font-family:monospace; opacity:0.7">(${accumulatedCode.length} chars)</span>`;
            
            // Live update of code view if active
            state.files['index.html'].content = accumulatedCode;
            if (state.activeFile === 'index.html') {
                 updateEditorContent(accumulatedCode);
            }
        });
        
        // Clean up markdown if present
        let finalHtml = accumulatedCode.replace(/```html/g, '').replace(/```/g, '').trim();
        
        // Update State
        state.files['index.html'].content = finalHtml;

        // Update Preview with full wrapper (Immediate feedback)
        updatePreview(finalHtml);
        
        // Sync with WebContainer
        if (webContainerInstance) {
            await writeFile('index.html', finalHtml);
        }

        // Update AI message
        contentEl.innerHTML = `I've built that for you. Check the preview!`;
        
        // Play sound
        successAudio.play().catch(() => {});
    } catch (error) {
        console.error(error);
        contentEl.innerHTML = `Sorry, something went wrong: ${error.message}`;
    }
    
    // Finish
    updateStatus(false);
    state.isGenerating = false;
}

async function generateWithAI(prompt, onChunk) {
    const response = await fetch("https://openrouter.ai/api/v1/chat/completions", {
        method: "POST",
        headers: {
            "Authorization": `Bearer ${API_KEY}`,
            "Content-Type": "application/json",
            "HTTP-Referer": window.location.href,
            "X-Title": "Lovable Clone"
        },
        body: JSON.stringify({
            "model": "x-ai/grok-4.1-fast",
            "stream": true,
            "messages": [
                {
                    "role": "system",
                    "content": "You are an expert frontend developer. Generate a modern, responsive HTML component using Tailwind CSS based on the user's request. Return ONLY the raw HTML code. Do not include markdown code blocks (```). Do not include <html>, <head>, or <body> tags. Just the component markup."
                },
                {
                    "role": "user",
                    "content": prompt
                }
            ]
        })
    });

    if (!response.ok) {
        const errorText = await response.text();
        console.error("OpenRouter API Error:", errorText);
        let errorMessage = `API Error ${response.status}`;
        try {
            const errorJson = JSON.parse(errorText);
            if (errorJson.error && errorJson.error.message) {
                errorMessage = errorJson.error.message;
            } else if (errorJson.message) {
                errorMessage = errorJson.message;
            }
        } catch (e) {
            errorMessage = `${errorMessage}: ${errorText.substring(0, 200)}`;
        }
        throw new Error(errorMessage);
    }

    const reader = response.body.getReader();
    const decoder = new TextDecoder();
    let buffer = '';

    while (true) {
        const { done, value } = await reader.read();
        if (done) break;

        buffer += decoder.decode(value, { stream: true });
        const lines = buffer.split('\n');
        buffer = lines.pop() || '';

        for (const line of lines) {
            const trimmed = line.trim();
            if (trimmed.startsWith('data: ')) {
                const dataStr = trimmed.slice(6);
                if (dataStr === '[DONE]') continue;
                try {
                    const data = JSON.parse(dataStr);
                    const content = data.choices[0]?.delta?.content;
                    if (content) onChunk(content);
                } catch (e) {
                    // Ignore partial parse errors
                }
            }
        }
    }
}

function addMessage(role, text) {
    const id = 'msg-' + Date.now();
    const div = document.createElement('div');
    div.className = `message ${role}`;
    div.id = id;
    div.innerHTML = `<div class="msg-content">${escapeHtml(text)}</div>`;
    els.messagesContainer.appendChild(div);
    els.messagesContainer.scrollTop = els.messagesContainer.scrollHeight;
    return id;
}

function updatePreview(html) {
    const frameDoc = els.previewFrame.contentDocument;
    
    // If we have a running server, don't use srcdoc, use the url
    if (state.serverUrl) {
        if (els.previewFrame.src !== state.serverUrl) {
            els.previewFrame.removeAttribute('srcdoc');
            els.previewFrame.src = state.serverUrl;
        }
        return;
    }

    const fullHtml = `
        <!DOCTYPE html>
        <html>
        <head>
            <script src="https://cdn.tailwindcss.com"></script>
            <style>
                body { font-family: sans-serif; }
            </style>
        </head>
        <body class="bg-white min-h-screen">
            ${html}
        </body>
        </html>
    `;

    // Update Iframe
    frameDoc.open();
    frameDoc.write(fullHtml);
    frameDoc.close();

    // Update Code View
    // state.files['index.html'].content is already updated in handleInput
    if (state.activeFile === 'index.html') {
        displayFile('index.html');
    }
}

// WebContainer Logic
async function initWebContainer() {
    if (!window.crossOriginIsolated) {
        logToTerminal('⚠️ Cross-Origin Isolation not enabled. WebContainer cannot start.', 'error');
        logToTerminal('To fix: Hosting on Netlify? Ensure netlify.toml is present.', 'system');
        return;
    }

    try {
        logToTerminal('Booting WebContainer...', 'system');
        webContainerInstance = await WebContainer.boot();
        state.webContainerLoaded = true;
        logToTerminal('WebContainer booted successfully.', 'success');
    } catch (e) {
        logToTerminal(`Failed to boot WebContainer: ${e.message}`, 'error');
    }
}

async function mountFiles() {
    if (!webContainerInstance) return;
    
    logToTerminal('Mounting files...', 'system');
    
    const fileSystem = {};
    for (const [filename, fileData] of Object.entries(state.files)) {
        fileSystem[filename] = {
            file: {
                contents: fileData.content
            }
        };
    }

    await webContainerInstance.mount(fileSystem);
    logToTerminal('Files mounted.', 'success');
}

async function writeFile(filename, content) {
    if (!webContainerInstance) return;
    await webContainerInstance.fs.writeFile(filename, content);
    // logToTerminal(`Updated ${filename}`, 'system');
}

async function startDevServer() {
    if (!webContainerInstance) return;

    logToTerminal('Installing dependencies...', 'system');
    
    const installProcess = await webContainerInstance.spawn('npm', ['install']);
    
    installProcess.output.pipeTo(new WritableStream({
        write(data) {
            logToTerminal(data, 'system');
        }
    }));

    if ((await installProcess.exit) !== 0) {
        logToTerminal('Installation failed', 'error');
        return;
    }

    logToTerminal('Starting server...', 'system');
    const startProcess = await webContainerInstance.spawn('npm', ['start']);

    startProcess.output.pipeTo(new WritableStream({
        write(data) {
            logToTerminal(data, 'system');
        }
    }));

    webContainerInstance.on('server-ready', (port, url) => {
        logToTerminal(`Server ready at ${url}`, 'success');
        state.serverUrl = url;
        // Switch preview to server URL
        els.previewFrame.removeAttribute('srcdoc');
        els.previewFrame.src = url;
    });
}

function logToTerminal(text, type = 'normal') {
    if (!els.terminalOutput) return;
    const line = document.createElement('div');
    line.className = `terminal-line ${type}`;
    line.textContent = text;
    els.terminalOutput.appendChild(line);
    els.terminalOutput.scrollTop = els.terminalOutput.scrollHeight;
}

function initEditor() {
    editor = new EditorView({
        doc: state.files[state.activeFile].content,
        extensions: [
            basicSetup,
            oneDark,
            html()
        ],
        parent: els.codeEditorMount
    });
}

function updateEditorContent(content) {
    if (!editor) return;
    const transaction = editor.state.update({
        changes: { from: 0, to: editor.state.doc.length, insert: content }
    });
    editor.dispatch(transaction);
}

function renderFileExplorer() {
    if (!els.fileList) return;
    els.fileList.innerHTML = '';
    
    Object.keys(state.files).forEach(filename => {
        const div = document.createElement('div');
        div.className = `file-item ${state.activeFile === filename ? 'active' : ''}`;
        
        let icon = 'file';
        if (filename.endsWith('.html')) icon = 'file-code';
        else if (filename.endsWith('.css')) icon = 'palette';
        else if (filename.endsWith('.js')) icon = 'file-code-2';
        else if (filename.endsWith('.json')) icon = 'braces';
        else if (filename.endsWith('.md')) icon = 'file-text';
        
        div.innerHTML = `<i data-lucide="${icon}"></i><span>${filename}</span>`;
        div.onclick = () => {
            state.activeFile = filename;
            displayFile(filename);
            renderFileExplorer();
        };
        els.fileList.appendChild(div);
    });
    
    if (window.lucide) window.lucide.createIcons();
}

function displayFile(filename) {
    if (state.files[filename]) {
        const content = state.files[filename].content;
        
        // Reconfigure editor for language
        if (editor) {
            updateEditorContent(content);
            
            // Ideally we would use Compartments for extensions, but for now let's just update content
            // To properly switch languages in CM6 we need a Compartment, but for this scope
            // we will just keep it simple or re-init if needed. 
            // Let's re-init for simplicity to get correct syntax highlighting
            
            editor.destroy();
            
            let langExt = html();
            if (filename.endsWith('.css')) langExt = css();
            if (filename.endsWith('.js')) langExt = javascript();
            
            editor = new EditorView({
                doc: content,
                extensions: [
                    basicSetup,
                    oneDark,
                    langExt,
                    EditorView.updateListener.of(update => {
                        if (update.docChanged) {
                            state.files[filename].content = update.state.doc.toString();
                        }
                    })
                ],
                parent: els.codeEditorMount
            });
        }
    }
}

function updateStatus(thinking) {
    if (thinking) {
        els.statusIndicator.innerHTML = 'Building...';
        els.statusIndicator.classList.add('thinking');
    } else {
        els.statusIndicator.innerHTML = 'Ready';
        els.statusIndicator.classList.remove('thinking');
    }
}

function wait(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
}

function escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
}
